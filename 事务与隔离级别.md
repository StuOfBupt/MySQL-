#### 1、事务

- 原子性（**A**tomicity）
  - 一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不产生任何影响。不能只执行其中一部分操作。
- 一致性（**C**onsistency）
  - 数据库总是**从一个一致性的状态转换到另一个一致性的状态**
- 隔离性（**I**solation）
  - **通常**一个事务所做的修改在最终提交之前，对其他事务是不可见的
- 持久性（**D**urability）
  - 一旦事务提交，其所做的修改是永久性的保存在数据库中，即便系统崩溃，修改的数据也不会丢失

#### 2、隔离级别

- 未提交读（Read UnCommitted）【脏读】
  - 事务中的修改，在没有提交之前，对其他事务也是可见的，其他事务可以读取未提交的数据
  - 实际中很少使用
  - **解决办法**：
    - 修改数据时添加排他锁，**事务提交后释放**。
    - 读取数据时添加共享锁（在事务读取数据时其他事务无法修改数据），**读取后释放**。
- 提交读（Read Committed）【不可重复读】
  - 事务在提交之前，所做的修改对其他事务是不可见的。
  - 也被称为不可重复读，因为执行两次同样的查询得到的结果可能不同
    - 原因：读取时加共享锁，**读取后释放**，导致在这个事务**读取数据后其他事物仍然可以修改数据，使得两次读取的数据不一致**
  - 解决方案：
    - 读取时加共享锁，**事务提交后才释放共享锁**
- 可重复读（Repeatable Read）
  - 解决了脏读的问题并保证了在同一个事务中多次读取同样记录的结果是一致的
  - 无法解决【幻读】问题，幻读是指：当某个事务在读取某个范围内的记录时，另外一个事物又在这个范围内**插入**了新的纪录，导致再次读取时产生“幻行”
  - 解决方案：
    - 加范围锁，锁定检索范围为只读
- 可串行化（Serializable）
  - 最高级别的隔离，强制事务串行执行，避免了幻读的问题，
  - 它会在读取的每一行数据上加锁，因此会导致大量的超时和锁争用问题，实际中很少使用，除非非常需要保证数据一致性。
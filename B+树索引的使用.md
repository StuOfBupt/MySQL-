## 聚簇索引和二级索引

- InnoDB会自动为主键（如果没有的话会自动添加）创建聚簇索引，聚簇索引的叶子节点包含**完整的数据**
- 可以为其他列创建索引（二级索引），二级索引的叶子节点包含索引列∩主键，因此通过二级索引查找用户记录需要找到主键后在通过聚簇索引查找需要的数据（如果只是索引列就不需要这一步），这一步称之为**回表**操作

## 索引的代价

- 空间代价：每建立一个索引都需要为之建一颗 B+树
- 时间代价：进行增删改查操作时，都需要更新所有的索引，因此索引很多时，维护操作也是一种额外的开销

## 联合索引适用的条件

- 全值匹配：搜索条件与索引列完全相同，无论在 where 中的顺序如何，都可以用到索引（查询优化器会自动为搜索条件排序）

- 左边列部分匹配：搜索语句不必是全部的索引列，只需要包含左边的就行

- 前缀匹配：对于类型为字符串的索引列来说，字符串的排序也是按照一个字符一个字符比较的，因此可以通过匹配前缀字符串来利用索引。

  ```sql
  SELECT * FROM person where name LIKE 'As%';
  ```

- 匹配范围：对多个列同时进行范围查找的话，**只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引**，后面的列需要遍历当前的搜索域

  ```sql
  SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
  ```

  - 通过条件对 name 进行范围查询，得到多条结果
  - 对这些结果继续通过 birthday > 1980-1-1进行过滤
    - 因为对于 birthday 列，只有 name 相同的时候才会按照顺序排列

- 用于排序，ORDER BY 的规则同索引一样，并且不能 ASC、DESC混用，也不能包含不是同一个索引的列

- 条件必须是单列形式

  ```sql
  SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
  ```

  无法用到索引，因为加了 upper 修饰

## 回表的代价

​		通过二级索引查询到主键，然后在通过聚簇索引查到数据，称之为一次回表。二级索引查到的记录在磁盘上是连续的，这个过程属于顺序 IO，但是主键对应的数据在磁盘上可能是不连续的，因此回表的查找属于随机 IO，顺序 IO 性能要比随机 IO 高很多，因此在**范围查询**时，**需要回表的次数越多，性能越差**，例如，查找的范围记录占总记录的 90%以上，使用回表的代价将远比全表扫描高得多。查询优化器将评估两种查找方式的代价，选择更加高效的方式。

​		因此最好在查询列中只包含索引列，这样不需要回表。

## 如何选择索引列

- 为用于搜索或者排序的列创建索引
- 考虑列的基数：列的基数是指某一列中不重复元素的个数，重复元素越多，值越集中，建立索引就没有必要（因为查出的数据重复太多，需要多次回表）。
- 索引列的类型尽量小
  - 数据类型越小，在查询时进行的比较操作越快
  - 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率
- 索引字符串值的前缀：字符串一般很长，那存储一个字符串就需要占用很大的存储空间。在为这个字符串列建立索引时，可以考虑只存储字符串前 n 位建立索引
  - 这样的话就无法使用排序了，因为只能比较前 n 位，前 n 位相同的字符串无法比较，只能用文件排序
- 


## 独立表空间结构

### 区（extent）、组

> 引入区的概念是为了让链表中相邻的页面离得更近，以减少随机 IO 的开销；在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照`区`为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机IO

- 一个页大小为 16KB，64 个页组成一个区（1MB）
- 256 个区为一组

![img](InnoDB的表空间.assets/16a739f33c4a1c3a.png)

- 第一个组的前三个页面固定，分别为：
  - FSP_HDR类型
  - IBUF_BITMAP 类型
  - INODE 类型
- 其余各个组的开始两个页面固定，分别为：
  - XDES 类型
  - IBUF_BITMAP 类型

### 段和碎片区

> 引入段的概念，是为了区分叶子节点和非叶子节点；
>
> 范围查询，其实是对`B+`树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣

叶子节点有自己独有的`区`，非叶子节点也有自己独有的`区`。

存放叶子节点的区的集合就算是一个`段`（`segment`），存放非叶子节点的区的集合也算是一个`段`。也就是说**一个索引会生成2个段**，一个叶子节点段，一个非叶子节点段。

> 引入碎片区的概念，是为了充分利用空间，当表中数据量很小时，分配一个区太浪费。在**一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的**，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。
>
> **碎片区直属于表空间，并不属于任何一个段**

为段分配存储空间的策略如下:

- 最开始时，段是从某个碎片区以单个页面为单位来分配存储空间的
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间

因此，段的定义可以认为是**某些零散的页面以及一些完整的区的集合**

### 区的分类

表空间是由若干个区组成的，这些区可分为 4 类：

- 空闲区：现在还没有用到这个区中的任何页面（可以被分配）
- 有剩余空间的碎片区：区中还有可用的页面。
- 没有剩余空间的碎片区：区中页面已经用尽
- 附属于某个段的区：这些区附属于某个段

通过 state 记录区的类型：

- FREE
- FREE_FRAG
- FULL_FRAG
- FSEG

> 处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，算是直属于表空间；而处于`FSEG`状态的区是附属于某个段的

### XDES Entry

为了管理区的一个结构

![img](InnoDB的表空间.assets/16a739f343654829.png)

- Segment ID :段 ID，唯一标识某个段

- ListNode:记录了上一个 XDES和下一个 XDES 的位置（双链表）

  - 4 字节的 Number 标识页号，2 字节的 Offset 标识页内偏移

  这样就能定位表空间内的某个位置

- State：标识这个区的类型

- Page State Bitmap：16个字节，也就是128个比特位。一个区有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用

### 向表中插入数据的过程

- 当段中数据较少的时候：

  - 如果存在还有**空闲空间的碎片区（FREE_FRAG）**，那么从该区中取一些零散的页把数据插进去；
  - 否则到表空间下申请一个**空闲的区（FREE）**，把该区的状态变为`FREE_FRAG`，然后从该新申请的区中取一些零散的页把数据插进去。之后不同的段使用零散页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了`FULL_FRAG`

  > 如何查找是否存在空闲的碎片区或者空闲的区？
  >
  > 答：通过XDES Entry 结构中的 ListNode,得到三个链表：
  >
  > - 将FREE 状态的区连成一个链表
  > - 将FREE_FRAG 状态的区连成一个链表
  > - 将FREE_FULL 状态的区连成一个链表

- 当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据了

  > 如何知道哪些区属于哪个段的呢？
  >
  > 答：**每个段都有它独立的链表**，所以可以根据段号（也就是`Segment ID`）来建立链表，有多少个段就建多少个链表；
  >
  > 继续细分，为每个段中的区对应的`XDES Entry`结构建立了三个链表：
  >
  > - FREE 链表：所有页面都是空闲的区对应的`XDES Entry`结构会被加入到这个链表。
  > - NOT_FULL链表：同一个段中，仍有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表
  > - FULL 链表：同一个段中，已经没有空闲空间的区对应的`XDES Entry`结构会被加入到这个链表。
  >
  > **此处的链表是附属于某个段的**，而不是直属于表空间

```c
表空间|
		 |----->FREE_LIST
		 |----->FREE_FRAG_LIST
		 |----->FREE_FULL_LIST
		 |
		 |--------段空间|
		 |			   		 |------>FREE_LIST
		 |						 |------>NOT_FULL_LIST
		 |						 |------>FULL_LIST
		 |				...			
		 |--------段空间|...
```

### 链表基节点

List Base Node 结构用于记录上述链表的信息：

![img](InnoDB的表空间.assets/16a739f388927e1c.png)

因此，只需要将基节点放置在表空间中**固定的位置**，这样想找定位某个链表就变得十分容易

### 段的结构

段不对应表空间中某一个连续的物理区域，而是一个**逻辑上的概念**，通过 INODE 来记录一下段中的属性：

![img](InnoDB的表空间.assets/16a739f4087c4a56.png)

- Segment ID：段 ID
- NOT_FULL_N_USED:记录在 NOT_FULL链表中已经用了多少个页
- 3 个 List Base Node：用于记录三个链表的头结点
- Magic Number：魔数，记录这个段结构是否已经被初始化了
- Fragment Array Entry：段是一些零散页面和一些完整的区的集合，每个Fragment Array Entry结构都**对应着一个零散的页面**，这个结构一共4个字节，表示一个零散页面的页号（超过 32 页时，将以区为单位分配空间）

### 各页面的详细情况

#### FSP_HDR

表空间的第一个页面，页号为 0，它存储了表空间的一些整体属性以及第一个组内256个区的对应的`XDES Entry`结构

![img](InnoDB的表空间.assets/16a739f4733af475.png)

- File Space Header：存储**表空间**的一些属性

  ![img](InnoDB的表空间.assets/16a739f47508ede5.png)

  - Space ID:表空间 ID

  - Size：当前表空间占用的页面数

  - FREE Limit：尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表

    > 表空间对应着具体的磁盘文件，一开始创建表空间的时候对应的磁盘文件中都没有数据，所以需要对表空间完成一个初始化操作，包括为表空间中的区建立`XDES Entry`结构，为各个段建立`INODE Entry`结构，建立各种链表等各种操作。我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的`XDES Entry`结构加入`FREE`链表，也可以选择只把一部分的空闲区加入`FREE`链表，等啥时候空闲链表中的`XDES Entry`结构对应的区不够使了，再把之前没有加入`FREE`链表的空闲区对应的`XDES Entry`结构加入`FREE`链表，中心思想就是啥时候用到啥时候初始化，因此为表空间定义了`FREE Limit`这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化

  - FRAG_N_USED:FREE_FRAG链表中已使用的页面数量

  - 三个 List Base Node ：表空间的三个链表基节点

  - Next Unused Segment ID :当前表空间中下一个未使用的 Segment ID

  - List Base Node for SEG_INODES_FULL List：SEG_INODES_FULL链表的基节点

  - List Base Node for SEG_INODES_FREE List：SEG_INODES_FREE链表的基节点

    > [INODE 类型中的链表基节点](#### INODE类型)

- XDES Entry：存储本组 256 个区的信息

  > 每个组的 XDES Entry 都在组中第一个页存储

#### XDES 类型

​	由于第一个组的第一个页面有些特殊，因为它也是整个表空间的第一个页面，所以除了记录本组中的所有区对应的`XDES Entry`结构以外，还记录着表空间的一些整体属性，这个页面的类型就是`FSP_HDR`类型，**整个表空间里只有一个这个类型的页面**。除去第一个分组以外，之后的每个分组的第一个页面只需要记录本组内所有的区对应的`XDES Entry`结构即可

![img](InnoDB的表空间.assets/16a739f475c0ec2a.png)

#### IBUF_BITMAP 类型

暂略

#### INODE 类型

![img](InnoDB的表空间.assets/16ef3a8df380813e.png)

- List Node for INODE Page List：存储上一个INODE页面和下一个INODE页面的指针（双向链表）

  > 因为一个表空间中可能存在超过85个段，所以可能一个`INODE`类型的页面不足以存储所有的段对应的`INODE Entry`结构，所以就需要额外的`INODE`类型的页面来存储这些结构。因此将这些`INODE`类型的页面串联成两个不同的链表：
  >
  > - SEG_INODES_**FULL**链表：该链表中的INODE类型的页面中已经没有空闲空间来存储额外的INODE Entry结构了
  > - SEG_INODES_**FREE**链表：该链表中的INODE类型的页面中还有空闲空间来存储额外的INODE Entry结构了。
  >
  > 基节点放在 FSP_HDR 中的 File Space Header 中。
  >
  > 创建一个新的段时：
  >
  > - 先看看`SEG_INODES_FREE`链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的`INODE`类型的页面，然后把该`INODE Entry`结构放到该页面中。当该页面中无剩余空间时，就把该页放到`SEG_INODES_FULL`链表中
  > - 如果`SEG_INODES_FREE`链表为空，则需要**从表空间的`FREE_FRAG`链表中申请一个页面**，修改该页面的类型为`INODE`，把该页面放到`SEG_INODES_FREE`链表中，与此同时把该`INODE Entry`结构放入该页面

- INODE Entry：段信息

  > 主要包括对应的段内零散页面的地址以及附属于该段的`FREE`、`NOT_FULL`和`FULL`链表的基节点。每个`INODE Entry`结构占用192字节，一个页面里可以存储`85`个这样的结构。

  

## 系统表空间

​		系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。它的表空间 ID（Space ID）是0。

参考：[表空间结构](https://juejin.cn/book/6844733769996304392/section/6844733770050830344)

